## zk-stark

zk-STARK（Zero-Knowledge Succinct Transparent Argument of Knowledge）并不直接依赖于哈希碰撞。它的证明机制基于多项式和线性代数，尤其是FRI（Fast Reed-Solomon Interactive Oracle Proof）子协议，用于确保证明的完整性和正确性。FRI阶段涉及对多项式的度进行递归约束，而不是寻找或避免哈希碰撞。

在STARK中，计算过程被转换成一组多项式方程，然后通过傅里叶变换进行处理。这个过程可以产生一个简洁的证明，该证明可以被任何人验证，而且不需要信任设置（与zk-SNARKs不同，后者通常需要一个初始化的信任设置阶段）。虽然哈希函数在STARKs中仍然有作用，例如用于随机化或者作为部分输入的指纹，但它们并不是核心的证明机制。

所以，STARK的核心不是基于哈希碰撞的，而是基于多项式和代数结构来构建透明和高效的零知识证明。

### 底层实现：

#### 多项式承诺和多项式校验：

ZK-Starks 将计算转换为多项式，利用多项式在有限域上的运算性质，通过多项式承诺和验证来实现证明的生成和验证。这种方法的优势在于多项式运算的**高效性和确定性**。

* 计算过程被转换为一组多项式方程，这些方程描述了计算的每一个步骤（计算过程则是通过对转换后的多项式进行算术运算来模拟进行）。 这些多项式计算通常在一个大的素数有限域上进行，用有限域的性质来简化计算并确保计算的确定性。
* 使用多项式的特性进行编码，通过**快速傅里叶变换（FFT）**处理这些多项式。
  * FFT 用于多项式的高效乘法和插值，在Stark 中加速设计的关键。
* 通过多项式的低度性和约束性来保证计算的正确性。

#### FRI 子协议

* FRI 是 ZK-STARK 中用于多项式检验的核心协议。
* 用于验证一个给定的多项式是否具有低度。
* 它通过递归地将多项式分解并检验其低阶系数，以此来检测潜在的欺诈。
* 这一过程**无需可信设置**，保证了系统的**透明性**。

**ZK-STARKs 通过 FRI 和其他优化技术实现了高效的验证过程。FFT 的使用使多项式运算更加高效，而 GPU 加速进一步提升了计算性能。这些优化使得 ZK-STARKs 能够处理大规模数据和复杂计算，同时保持高效的证明生成和验证过程。**



#### Hash function

**哈希函数的作用**：

- 虽然 ZK-STARK 的核心不是基于哈希碰撞，但哈希函数在系统中仍然扮演重要角色，例如用于随机化和生成指纹。
- 哈希函数帮助增强系统的安全性和随机性，但不作为核心证明机制。

####  随机预言机（Random Oracle Model）：

- 虽然 ZK-STARKs 尽量减少对外部随机预言机的依赖，但在生成证明过程中会用到随机性。例如，在 FRI 中用于生成挑战，以确保证明的不可伪造性和安全性。

#### Turbo/GPU 优化

* 在生成证明时，zk-STARKs的实现经常利用并行计算技术，如GPU加速，以及算法上的优化（如Turbo Proofs），来减少计算时间和资源消耗。

####  透明性和无需可信设置

* zk-STARKs的设计确保了证明过程不需要任何信任设置阶段，所有必要的参数都可以公开生成，增加了系统的透明度和去中心化特性。



### 如何实现隐私保护

1. **零知识特性**：
   - ZK-STARK 提供零知识证明，即证明者可以证明某个声明的正确性而不泄露任何额外信息。
   - 证明的生成和验证过程保证了隐私性，验证者无法从证明中提取出计算的任何细节。
2. **非交互性和透明性**：
   - ZK-STARK 是非交互的，意味着证明者可以独立生成证明，验证者无需与证明者互动即可验证证明。
   - 透明性保证了证明过程不依赖任何可信第三方，进一步增强了隐私和安全性。
3. **高效性**：
   - ZK-STARK 的证明生成和验证过程相对高效，适合大规模数据和复杂计算的场景。
   - 通过多项式和线性代数的优化，ZK-STARK 可以生成简洁且高效的证明。



#### 总结： 

ZK-STARK 通过将**计算转换成多项式方程**，并利用 **FRI 子协议进行多项式检验**，实现了高效、透明和零知识的证明过程。虽然哈希函数在系统中有辅助作用，但 ZK-STARK 的核心机制是基于**多项式和代数结构**来构建的。这使得 ZK-STARK 能够在保证隐私和安全性的同时，提供高效的证明和验证方法。



### 区别

zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）和zk-STARK（Zero-Knowledge Scalable Transparent Argument of Knowledge）都是零知识证明（Zero-Knowledge Proof, ZKP）的两种不同实现，它们允许一方（证明者）向另一方（验证者）证明某些知识是真实的，而无需透露任何具体信息。以下是它们的主要区别：

1. **信任设置（Trust Setup）**：
   - **zk-SNARKs**：需要一个初始的公信力设置（trusted setup）阶段，这个阶段可能产生一些潜在的脆弱性，如如果参与者之一是恶意的，可能会破坏整个系统的安全性。
   - **zk-STARKs**：不需要这样的公信力设置，因此减少了信任假设，提供了更强的安全性保证。
2. **证明的长度和效率**：
   - **zk-SNARKs**：生成的证明通常较短，但涉及复杂的数学结构，包括非线性的伽罗华域运算，这可能使证明的构造和验证复杂。
   - **zk-STARKs**：证明通常比zk-SNARKs更大，但验证过程更为直接和透明，基于线性代数和多项式，更容易理解和实现。
3. **可验证性和透明度**：
   - **zk-STARKs**：因为没有信任设置，它们是透明的，意味着任何人都可以检查和验证证明的每个步骤，增加了公众的可审计性。
   - **zk-SNARKs**：由于其内在的复杂性，证明的验证过程不如zk-STARKs透明。
4. **计算需求**：
   - **zk-STARKs**：通常需要更多的计算资源来生成证明，但验证过程相对更简单和高效。
   - **zk-SNARKs**：生成证明可能更快，但验证过程可能需要更多步骤。
5. **后量子安全性**：
   - **zk-STARKs**：被认为在量子计算机时代可能更具抵抗力，因为它们不依赖于易受量子攻击的数学结构。
   - **zk-SNARKs**：某些类型的zk-SNARKs依赖于某些假设，如RSA或椭圆曲线，这些假设在量子计算面前可能较弱。

总的来说，zk-STARKs提供了更高的透明度和更强的安全性，而zk-SNARKs则以其简洁性和效率著称。

