# `Risc0`example project

Example 

```shell
total 176
-rw-r--r--  1 scc  staff  53794 May  5 12:00 Cargo.lock
-rw-r--r--  1 scc  staff    216 May  5 11:59 Cargo.toml
-rw-r--r--  1 scc  staff  11357 May  5 11:59 LICENSE
-rw-r--r--  1 scc  staff   4399 May  5 11:59 README.md
drwxr-xr-x  4 scc  staff    128 May  5 11:59 host
drwxr-xr-x  6 scc  staff    192 May 25 10:19 methods
-rw-r--r--  1 scc  staff     88 May  5 11:59 rust-toolchain.toml
```

简单理解为`methods` 下是可自定义的程序，实际的执行也是将这部分程序编译为ELF文件。

`host` 则是验证逻辑，prover 检查并证明ELF的有效性，并输出`receipt`

```rust
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let input: u32 = 15 * u32::pow(2, 27) + 1;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover
        .prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF)
        .unwrap();

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let output: u32 = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(GUEST_CODE_FOR_ZK_PROOF_ID)
        .unwrap();
  
		assert_eq!(input,output);
    println!("Hello, world! I generated a proof of guest execution! {} is a public output from journal", output);
}
```

> 设置一个PI，在自定义的程序中output = PI。



## prove

在之前的笔记中也大致介绍过了，risc0 proof的生成，验证分为三种方式： remote，dev-mode，local。**本节中以local为例进行分析**。

```rust
//zkvm/src/host/client/prove/mod.rs
pub fn default_prover() -> Rc<dyn Prover> {
    let explicit = std::env::var("RISC0_PROVER").unwrap_or_default();
    if !explicit.is_empty() {
        return match explicit.to_lowercase().as_str() {
            "bonsai" => Rc::new(BonsaiProver::new("bonsai")),
            "ipc" => Rc::new(ExternalProver::new("ipc", get_r0vm_path())),
            #[cfg(feature = "prove")]
            "local" => Rc::new(self::local::LocalProver::new("local")),
            _ => unimplemented!("Unsupported prover: {explicit}"),
        };
    }

    if !is_dev_mode()
        && std::env::var("BONSAI_API_URL").is_ok()
        && std::env::var("BONSAI_API_KEY").is_ok()
    {
        return Rc::new(BonsaiProver::new("bonsai"));
    }

    if cfg!(feature = "prove") {
        #[cfg(feature = "prove")]
        return Rc::new(self::local::LocalProver::new("local"));
    }

    Rc::new(ExternalProver::new("ipc", get_r0vm_path()))
}
```

根据不同的配置启动不同的prove service：

* `bonsai`  `BONSAI_API_KEY`   `BONSAI_API_URL` 是很必须设置的。
* `ipc`  [ExternalProver] 证明使用 `r0vm` 子进程。注意：必须安装`r0vm`。要指定“r0vm”的路径，请使用“RISC0_SERVER_PATH”
* `local` 本地的prover 需要启用 prove features

运行日志：

```shell
2024-05-27T06:47:27.122928Z  INFO executor: risc0_zkvm::host::server::exec::executor: execution time: 1.8ms
2024-05-27T06:47:27.122954Z  INFO executor: risc0_zkvm::host::server::session: number of segments: 1
2024-05-27T06:47:27.122957Z  INFO executor: risc0_zkvm::host::server::session: total cycles: 131072
2024-05-27T06:47:27.122958Z  INFO executor: risc0_zkvm::host::server::session: user cycles: 13368
2024-05-27T06:47:27.122960Z  INFO executor: risc0_zkvm::host::server::session: cycle efficiency: 10%
2024-05-27T06:47:27.122964Z  INFO risc0_zkvm::host::server::prove::prover_impl: prove_session: cpu, exit_code = Halted(0), journal = Some("2f0000008e64617c59a3e29953fe4d5bcbda0a28b7ba17094c117957737188921cc6226a")

```

从上述日志中可以看出local prove的生成，底层实际执行的是`prove_session`



```rust
risc0/risc0/zkvm/src/host/client/prove/mod.rs
/// Prove zkVM execution starting from the specified ELF binary.
    fn prove(&self, env: ExecutorEnv<'_>, elf: &[u8]) -> Result<Receipt> {
        self.prove_with_ctx(
            env,
            &VerifierContext::default(),
            elf,
            &ProverOpts::default(),
        )
    }
```

local prove 的核心

```rust
fn prove_session(&self, ctx: &VerifierContext, session: &Session) -> Result<ProveInfo> {
  
  // 1 generate segment proof
  let mut segments = Vec::new();
        for segment_ref in session.segments.iter() {
            let segment = segment_ref.resolve()?;
            for hook in &session.hooks {
                hook.on_pre_prove_segment(&segment);
            }
            segments.push(self.prove_segment(ctx, &segment)?);
            for hook in &session.hooks {
                hook.on_post_prove_segment(&segment);
            }
  
  //2 session_assumption_receipts
   let (assumptions, session_assumption_receipts) = session
            .assumptions
            .iter()
            .cloned()
            .unzip::<_, _, Vec<_>, Vec<_>>();
          
   let last_segment = segments.last_mut().ok_or(anyhow!("session is empty"))?;
        last_segment
            .claim
            .output
            .merge_with(
                &session
                    .journal
                    .as_ref()
                    .map(|journal| Output {
                        journal: MaybePruned::Pruned(journal.digest()),
                        assumptions: assumptions.into(),
                    })
                    .into(),
            )
            .context("failed to merge output into final segment claim")?;
          
  // 3 generate CompositeReceipt
  let composite_receipt = CompositeReceipt {
            segments,
            assumption_receipts,
            verifier_parameters,
        };
	
  composite_receipt.verify_integrity_with_context(ctx)?;

	// 4 Compress the receipt to the requested level.
   let receipt = match self.opts.receipt_kind {
            ReceiptKind::Composite => Receipt::new(
                InnerReceipt::Composite(composite_receipt),
                session.journal.clone().unwrap_or_default().bytes,
            ),
            ReceiptKind::Succinct => {
                let succinct_receipt = self.composite_to_succinct(&composite_receipt)?;
                Receipt::new(
                    InnerReceipt::Succinct(succinct_receipt),
                    session.journal.clone().unwrap_or_default().bytes,
                )
            }
            ReceiptKind::Groth16 => {
                let succinct_receipt = self.composite_to_succinct(&composite_receipt)?;
                let groth16_receipt = self.succinct_to_groth16(&succinct_receipt)?;
                Receipt::new(
                    InnerReceipt::Groth16(groth16_receipt),
                    session.journal.clone().unwrap_or_default().bytes,
                )
            }
         };
   receipt.verify_integrity_with_context(ctx)?;
  	
}
```

大致分为以下几步：

* `segment` ： 迭代session中的每个segments，调用hook `hook.on_pre_prove_segment(&segment);`  然后调用 `prove_segment` 方法生成证明，最后再次调用所有的钩子函数的 `on_post_prove_segment` 方法。**这个过程实现了对会话中每个段落的独立证明。**
* `Assumption` ：函数接下来处理 `session` 中的所有假设。它首先将假设和假设收据分离，然后将包括日志摘要和假设在内的输出合并到最后一个段落中。**这个过程实现了对session中所有假设的处理和证明。**
* `composite_receipt`:  聚合分段证明，函数检查收据的完整性`verify_integrity_with_context(ctx)?` ，并确保收据的声明与 `session` 的声明匹配。**这个过程实现了对session proof的完整性检查。**
* `Compress the receipt` : 收据压缩为 `Composite`、`Succinct` 或 `Groth16` 类型，然后再次检查收据的完整性，并确保收据的声明与 `session` 的声明匹配。**这个过程实现了对session证明的压缩和再次完整性检查**。

